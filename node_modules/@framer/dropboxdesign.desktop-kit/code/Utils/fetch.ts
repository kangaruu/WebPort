import { useState, useEffect, useLayoutEffect } from "react"
import { RenderTarget } from "framer"
import { Dropbox } from "dropbox"

// Custom hook for fetching images from Unsplash
export function useUnsplashAPI({ size, search }) {
  const [imageUrl, setImageUrl] = useState("")
  const [isImageLoading, setIsImageLoading] = useState(false)

  const baseUrl = "https://source.unsplash.com"
  const route = search === "" ? "/random" : "/featured"
  const url = `${baseUrl}${route}/${size}x${size}?${search}`
  useLayoutEffect(() => {
    fetch(url)
      .then(response => {
        setIsImageLoading(true)
        setImageUrl(response.url)
        setIsImageLoading(false)
      })
      .catch(error => {
        setIsImageLoading(false)
        return error
      })
  }, [search, RenderTarget.canvas])

  return { imageUrl, isImageLoading }
}

function getCleanToken(accessTokenURL) {
  let cleanToken = ""
  if (accessTokenURL.startsWith("http")) {
    cleanToken = accessTokenURL.split("=")[1].split("&")[0] // Grab the token as the first variable in the string
    return cleanToken
  } else {
    return accessTokenURL
  }
}

// Custom hook for fetching Dropbox data. Includes flags for caching and thumbnails.
export function useDropboxAPI({
  accessTokenURL,
  currentPath,
  isCacheOn = false,
  showThumbnails = true
}) {
  const token = getCleanToken(accessTokenURL)
  const dbx = new Dropbox({
    accessToken: token,
    fetch: fetch
  })

  const [files, setFiles] = useState([])
  const [isDataLoading, setIsDataLoading] = useState(false)
  const [pathMetaData, setPathMetaData] = useState(null)

  useEffect(() => {
    if (!isCacheOn) {
      sessionStorage.clear()
    }
  }, [isCacheOn])

  useEffect(() => {
    const fetchDropbox = async () => {
      const cachedContent = JSON.parse(
        sessionStorage.getItem(token + "/" + currentPath)
      )

      if (cachedContent && isCacheOn) {
        setFiles(cachedContent) // Use cache if found for current path. NOTE: This currently doesn't respect the check for thumbnails prior to cache being turned on
        setIsDataLoading(false)
      } else {
        setIsDataLoading(true)

        try {
          const content = await dbx
            .filesListFolder({
              path: currentPath,
              include_has_explicit_shared_members: true
            })
            .then(res =>
              showThumbnails ? fetchThumbnails(res.entries) : res.entries
            )
          // Cache the content if enabled
          if (isCacheOn) {
            sessionStorage.setItem(
              token + "/" + currentPath,
              JSON.stringify(content)
            )
          }

          setFiles(content)
        } catch (error) {
          setIsDataLoading(false)
          console.log("Error getting Dropbox content...", error)
          return error
        }

        setIsDataLoading(false)
      }
    }

    const fetchThumbnails = async filesToParse => {
      const paths = filesToParse
        .filter(file => file[".tag"] === "file")
        .map(file => ({
          path: file.path_lower,
          size: "w128h128"
        }))
      let newStateFiles = [...filesToParse]

      try {
        let response = await dbx.filesGetThumbnailBatch({
          entries: paths
        })
        // find the matching files and add thumbnail
        response.entries.forEach(file => {
          let indexToUpdate = filesToParse.findIndex(
            stateFiles =>
              file["metadata"]["path_lower"] === stateFiles["path_lower"]
          )
          newStateFiles[indexToUpdate]["thumbnail"] = file["thumbnail"]
        })
        return newStateFiles
      } catch (error) {
        console.error("Error retrieving thumbnails", error)
        return error
      }
    }

    const fetchMetaData = async () => {
      if (currentPath !== "") {
        const metadata = await dbx.filesGetMetadata({
          path: currentPath
        })
        setPathMetaData(metadata)
      } else {
        setPathMetaData(null)
      }
    }

    if (token) {
      fetchDropbox()
      fetchMetaData()
    }
  }, [
    currentPath,
    accessTokenURL,
    isCacheOn,
    showThumbnails,
    RenderTarget.canvas
  ])
  return { files, isDataLoading, pathMetaData }
}
